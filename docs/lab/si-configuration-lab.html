<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>si-configuration: Using an Idempotent Receiver and Filter invalid Dinings</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.70.0"><link rel="start" href="index.html" title="Enterprise Spring - Lab Documentation"><link rel="up" href="index.html" title="Enterprise Spring - Lab Documentation"><link rel="prev" href="si-intro-lab.html" title="si-intro: Refactoring from JMS to Spring Integration"><link rel="next" href="si-advanced-lab.html" title="si-advanced: Splitter and File System Integration"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns="http://www.w3.org/TR/xhtml1/transitional" style="background-color:white;border:none;height:73px;border:1px solid black;"><a style="border:none;" href="http://www.springframework.org/" title="The Spring Framework"><img style="border:none;" src="images/xdev-spring_logo.jpg"></img></a><a style="border:none;" href="http://www.springsource.com/" title="SpringSource"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/springsource-banner-rhs.jpg"></img></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="si-configuration-lab"></a>si-configuration: Using an Idempotent Receiver and Filter invalid Dinings</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="si-configuration-lab-introduction"></a>1.&nbsp;Introduction</h2></div></div></div><div class="orderedlist"><p class="title"><b>This lab involves the following use cases:</b></p><ol type="1"><li><p>Refactor the messaging configuration to ensure idempotency</p><div class="orderedlist"><ol type="a"><li><p>Prevent duplicate messages from reaching the Reward Network</p></li><li><p>Send confirmations no matter what</p></li></ol></div></li><li><p>Filter out invalid Dinings</p></li></ol></div><div class="orderedlist"><p class="title"><b>Topics covered</b></p><ol type="1"><li><p>Idempotent Receiver pattern</p></li><li><p>Filtering Messages</p></li><li><p>Working with the global errorChannel for polling receivers</p></li></ol></div><div class="orderedlist"><p class="title"><b>Specific subjects you'll gain experience with</b></p><ol type="1"><li><p>The <span class="emphasis"><em>chain</em></span> element</p></li><li><p>Implementing a custom handler</p></li><li><p>Defining a filter using SpEL</p></li><li><p>Bridging a channel for testing purposes</p></li></ol></div><p>
Estimated completion time: 40 minutes
  </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="si-configuration-lab-instructions"></a>2.&nbsp;Instructions</h2></div></div></div><p>
In this lab you will improve the Reward Network application to allow the Credit Card Processors to hand off their Dinings faster.  
</p><p>
An Idempotent Receiver is a component that ensures that it will be in the same state after each reception of a certain message. So no matter how many times you receive a certain Dining, after processing there should be exactly one Reward for it. This is something we can guarantee even without using distributed transactions. The only thing you need to do to guarantee this is to check if you have already processed the Dining and only process it if you haven't. After ensuring that the Dining was processed you will send a confirmation no matter what.
 </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5882"></a>2.1.&nbsp;Part 1. Make the RewardNetwork Idempotent</h3></div></div></div><p>
The Credit Card Processor will send a Dining. What does this dining represent?
  </p><p>
A Dining describes a real life event: someone has paid for a dinner with his creditcard. It tells you at what time this event happened (timestamp), where it happened (merchant number) and finally who did the dining (creditcard number). These three bits of information are <span class="emphasis"><em>universally unique</em></span>. For your convenience this has been captured in the Dining transactionId by the Credit Card Processor. 
  </p><p>
This allows you to check if you have already processed this Dining and act accordingly. The Credit Card Processor can send the Dining as many times as it likes and the RewardNetwork can confirm the reward for it as many times as requested, as long as we ensure the reward isn't duplicated.
  </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5894"></a>2.1.1.&nbsp;Set up the messaging system</h4></div></div></div><p>
We're going to work with a simplified setup that doesn't involve JMS or email, since it's not needed for this lab. The context has been split up in three parts. You will be working on <span class="emphasis"><em>spring-integration-idempotent-receiver-config.xml</em></span> first. Open the file and examine its contents: we're using a <span class="emphasis"><em>dinings</em></span> and <span class="emphasis"><em>confirmations</em></span> channel with a <span class="emphasis"><em>service-activator</em></span> that ties them together by calling the <span class="emphasis"><em>rewardNetwork</em></span> again. However, there's no inbound gateway that enters <span class="emphasis"><em>Dining</em></span> messages into the system, the testing code will do that directly instead.
    </p><p>
Open up <span class="emphasis"><em>IdempotentRewardNetworkIntegrationTests</em></span> and complete <span class="emphasis"><em>TODO 1</em></span> within the <span class="emphasis"><em>idempotence</em></span> test method. Run the test case.
   </p><p>
The second assertion should fail. This indicates that the <span class="emphasis"><em>RewardNetwork</em></span> is being invoked multiple times for the same dining event. In other words, our reward processing is <span class="emphasis"><em>not</em></span> idempotent.
     </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
        Note that this test doesn't use the real <span class="emphasis"><em>rewardNetwork</em></span> and <span class="emphasis"><em>rewardRepository</em></span>, but mocks. Check the <span class="emphasis"><em>test-context.xml</em></span> file to see how the mocks are set up.
      </p></td></tr></table></div><p>
   </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5949"></a>2.1.2.&nbsp;Prevent duplicate dining submissions</h4></div></div></div><p>
Open up <span class="emphasis"><em>spring-integration-idempotent-receiver-config.xml</em></span> if you haven't already.
   </p><p>
The check if a Dining for the transactionId at hand has already been processed needs to happen before calling the <span class="emphasis"><em>rewardAccountFor(Dining)</em></span> method. To accomplish this you're going to wrap the the relevant part of the message flow in a <span class="emphasis"><em>&lt;chain/&gt;</em></span> with some extra endpoints. A chain will automatically wire all its children together linearly using direct channels. Wrap a chain around the rewardNetwork service activator (<span class="emphasis"><em>TODO 02</em></span>).
   </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
The chain should have input and output channels, but the service-activator will no longer need any explicit channel configuration.
   </td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5970"></a>2.1.3.&nbsp;Send the confirmation</h4></div></div></div><p>
Whenever a message is received a confirmation needs to be sent, even if nothing has happened. Otherwise our service wouldn't be idempotent. More importantly, how else would the Credit Card Processor know that they don't have to retry?
   </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
It is possible that the Credit Card Processor already has decided to retry a Dining when you are processing it but before you've sent a RewardConfirmation. This shouldn't be a problem, but you should be aware of this when you're correlating messages in the Credit Card Processors log files, otherwise you might think there is a bug. Just remember what is unique: an actual dining transaction - all communication about it could be duplicated.
   </p></td></tr></table></div><p>
Now add another service-activator to the chain <span class="emphasis"><em>before</em></span> the rewardNetwork. For your convenience an AlreadyRewardedConfirmer has been implemented that will side track the message out of the chain in case it was already processed. The only thing you need to do is point the service activator to the <span class="emphasis"><em>alreadyRewardedConfirmer</em></span> bean (<span class="emphasis"><em>TODO 03</em></span>).
   </p><p>
Look at the code and configuration for the <span class="emphasis"><em>alreadyRewardedConfirmer</em></span> to see how it works: it returns the received <span class="emphasis"><em>Dining</em></span> when no confirmation was found so that the chain passes that to the <span class="emphasis"><em>rewardNetwork</em></span>, but short-circuits the chain by returning <span class="emphasis"><em>null</em></span> when a confirmation was found. To ensure that this confirmation is still sent to the <span class="emphasis"><em>confirmations</em></span> channel it uses a simple gateway. 
   </p><p>
Run the <span class="emphasis"><em>IdempotentRewardNetworkIntegrationTests</em></span> again. It should now pass. Once it does, open the <span class="emphasis"><em>RewardMessagingIntegrationTests</em></span>, remove the <span class="emphasis"><em>@Ignore</em></span> on the <span class="emphasis"><em>sendDiningTwice</em></span> method (<span class="emphasis"><em>TODO 04</em></span>) and run the test. Make sure that it passes before you start with the next part of the lab.
   </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6023"></a>2.2.&nbsp;Part 2. Filtering broken messages</h3></div></div></div><p>
So far we've worked with valid input for the <span class="emphasis"><em>rewardNetwork</em></span> (and the newly added <span class="emphasis"><em>alreadyRewardedConfirmer</em></span>). But what happens when the input is broken? If handling the Dining happens in the same thread, the caller simply receives the exception that's thrown as a result of the invalid data. To test this, open <span class="emphasis"><em>InvalidDiningsIntegrationTests</em></span> and complete <span class="emphasis"><em>TODO 05</em></span> by sending the <span class="emphasis"><em>invalidDining</em></span> to the "dinings" channel using the provided template. Run the test and check the exception that's thrown. 
  </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6043"></a>2.2.1.&nbsp;Filter out invalid messages</h4></div></div></div><p>
Instead of allowing invalid Dinings to reach the <span class="emphasis"><em>rewardNetwork</em></span>, we want to filter them out before they reach the service activator. Since you have a chain in place already, that only requires an additional filter as the first endpoint in the chain. Add a filter to the chain that filters out Dinings that have one of their properties set to <span class="emphasis"><em>null</em></span> (<span class="emphasis"><em>TODO 06</em></span>).
      </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>
This is a good candicate for using an expression instead of a Java implementation: something in the form of <span class="emphasis"><em>payload.firstProperty != null and payload.secondProperty != null ...</em></span> will do the trick. 
        </p></td></tr></table></div><p>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
If you see an error on the service-activator after adding the filter that says it must be followed by attribute specifications, "&gt;" or "/&gt;" then please ignore it: that's a bug in the tooling.
        </p></td></tr></table></div><p>
Run the test again and make sure there's no exception this time.  
    </p><p>
In some scenarios silently dropping invalid messages is a fine solution. In other cases you might want to forward the message to some discard channel or throw an exception instead: enable the latter by setting the <span class="emphasis"><em>throw-exception-on-rejection</em></span> attibute of the filter to <span class="emphasis"><em>true</em></span> (<span class="emphasis"><em>TODO 07</em></span>). Run the test again to see the difference.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6079"></a>2.2.2.&nbsp;Test error handling for asynchronous message handling</h4></div></div></div><p>
With synchronous endpoints, it's easy to tell the difference between successful processing or an exception as you just saw. The situation is very different when the invalid Dining is processed asynchronously on a different thread, however. To see this, open <span class="emphasis"><em>spring-integration-idempotent-receiver-config.xml</em></span> and change the "dinings" channel to a QueueChannel by adding a <code class="literal">&lt;queue&gt;</code> subelement to it (<span class="emphasis"><em>TODO 08</em></span>). Note that a default poller is already configured in <span class="emphasis"><em>spring-integration-infrastructure-config.xml</em></span>, so no additional configuration is needed.
   </p><p>
Run the <span class="emphasis"><em>InvalidDiningsIntegrationTests</em></span> again. Notice that there's no exception this time, even though the filter throws one. That's because the exception was thrown from a different thread, so Spring Integration has wrapped it and sent it to the "errorChannel" channel. A logging channel adapter that logs the exception message is already set up, so the Console view should show the exception. What we want is a good way to test for the exception message to arrive on the <span class="emphasis"><em>errorChannel</em></span>: just looking at the Console is no good for an automated test of course. 
   </p><p>
A common technique for checking for expected messages in a test is to <span class="emphasis"><em>bridge</em></span> the channel that will contain the expected message to a dedicated test queue channel. You can then receive from that test channel in your test and check the message. 
   </p><p>
Open <span class="emphasis"><em>test-context.xml</em></span> and complete <span class="emphasis"><em>TODO 09</em></span> by creating a new QueueChannel called "errorTestChannel" and define a bridge that forwards messages from the default "errorChannel" to this "errorTestChannel". 
     </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
Note that bridging or subscribing to a point-to-point instead of a publish-subscribe channel with an existing receiver in the test context would not be a good idea, as it interferes with the intended receiver. You could use a global wire tap element then instead of a bridge (new feature in Spring Integration 2.0.4):
        </p><pre class="programlisting">&lt;int:wire-tap channel="errorTestChannel" pattern="errorChannel" /&gt;</pre><p>
      </p></td></tr></table></div><p>
   </p><p>
Then switch to the <span class="emphasis"><em>InvalidDiningsIntegrationTests</em></span> and complete <span class="emphasis"><em>TODO 10</em></span> by using the provided MessagingTemplate to check that there's a message on the "errorTestChannel" with a payload of type <span class="emphasis"><em>MessageRejectedException</em></span>; this is the exception thrown by the filter when it rejects the message with the invalid Dining. 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p> 
The template is configured with a receive timeout already, so it will simply return <span class="emphasis"><em>null</em></span> when there's no message on a channel that you try to receive from.
     </p></td></tr></table></div><p>
   </p><p>When the test passes, switch to the <span class="emphasis"><em>RewardMessagingIntegrationTests</em></span> and remove the <span class="emphasis"><em>@Ignore</em></span> on the <span class="emphasis"><em>sendInvalidDining</em></span> method (<span class="emphasis"><em>TODO 11</em></span>). Make sure the test passes now. 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
Note that this test uses a diffent approach to check for the expected message: it subscribes a handler to the "errorChannel" and waits to give the system time to process the message before checking the result (after all, it's asynchronous). In general the bridging approach is preferable, as it relies on the receive call to wait for you, whereas this approach requires manual waits. The approach in this test does not require a dedicated test configuration file with the QueueChannel and bridge, though.
      </p></td></tr></table></div><p>
    When the test passes, you've successfully completed the lab.   You might like to tidy
    the output by suppressing the stack-traces from the exceptions that we are expecting
    as part of the tests.  We don't care about them and they make the tests look like
    they are failing. (TODO 12).
   </p></div></div></div></div><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navfooter"><hr></hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="si-intro-lab.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="si-advanced-lab.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">si-intro: Refactoring from JMS to Spring Integration&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.springsource.com/" title="SpringSource">By SpringSource</a></span></td><td width="40%" align="right" valign="top">&nbsp;si-advanced: Splitter and File System Integration</td></tr></table></div></body></html>